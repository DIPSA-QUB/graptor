// -*- C++ -*-

#include <cstdint>
#include <type_traits>

#include "graptor/graptor.h"

alignas(64) const uint8_t increasing_sequence_epi8[64] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63
};

alignas(64) const uint16_t increasing_sequence_epi16[16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
};

alignas(64) const uint32_t increasing_sequence_epi32[16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
};

alignas(64) const uint64_t increasing_sequence_epi64[16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
};

alignas(64) const uint32_t movemask_lut_epi32[16*4] = { // 16-bit fields?
    0,      0,      0,      0,      // mask 0
    0xffff, 0,      0,      0,      // mask 1
    0,      0xffff, 0,      0,      // mask 2
    0xffff, 0xffff, 0,      0,      // mask 3
    0,      0,      0xffff, 0,      // mask 4
    0xffff, 0,      0xffff, 0,      // mask 5
    0,      0xffff, 0xffff, 0,      // mask 6
    0xffff, 0xffff, 0xffff, 0,      // mask 7
    0,      0,      0,      0xffff, // mask 8
    0xffff, 0,      0,      0xffff, // mask 9
    0,      0xffff, 0,      0xffff, // mask 10
    0xffff, 0xffff, 0,      0xffff, // mask 11
    0,      0,      0xffff, 0xffff, // mask 12
    0xffff, 0,      0xffff, 0xffff, // mask 13
    0,      0xffff, 0xffff, 0xffff, // mask 14
    0xffff, 0xffff, 0xffff, 0xffff  // mask 15
};

alignas(64) const uint16_t movemask_lut_epi16[16*4] = {
    0,      0,      0,      0,      // mask 0
    0xffff, 0,      0,      0,      // mask 1
    0,      0xffff, 0,      0,      // mask 2
    0xffff, 0xffff, 0,      0,      // mask 3
    0,      0,      0xffff, 0,      // mask 4
    0xffff, 0,      0xffff, 0,      // mask 5
    0,      0xffff, 0xffff, 0,      // mask 6
    0xffff, 0xffff, 0xffff, 0,      // mask 7
    0,      0,      0,      0xffff, // mask 8
    0xffff, 0,      0,      0xffff, // mask 9
    0,      0xffff, 0,      0xffff, // mask 10
    0xffff, 0xffff, 0,      0xffff, // mask 11
    0,      0,      0xffff, 0xffff, // mask 12
    0xffff, 0,      0xffff, 0xffff, // mask 13
    0,      0xffff, 0xffff, 0xffff, // mask 14
    0xffff, 0xffff, 0xffff, 0xffff  // mask 15
};

alignas(64) const uint8_t movemask_lut_epi8[16*4] = {
    0,    0,    0,    0,    // mask 0
    0xff, 0,    0,    0,    // mask 1
    0,    0xff, 0,    0,    // mask 2
    0xff, 0xff, 0,    0,    // mask 3
    0,    0,    0xff, 0,    // mask 4
    0xff, 0,    0xff, 0,    // mask 5
    0,    0xff, 0xff, 0,    // mask 6
    0xff, 0xff, 0xff, 0,    // mask 7
    0,    0,    0,    0xff, // mask 8
    0xff, 0,    0,    0xff, // mask 9
    0,    0xff, 0,    0xff, // mask 10
    0xff, 0xff, 0,    0xff, // mask 11
    0,    0,    0xff, 0xff, // mask 12
    0xff, 0,    0xff, 0xff, // mask 13
    0,    0xff, 0xff, 0xff, // mask 14
    0xff, 0xff, 0xff, 0xff  // mask 15
};

// This 3 shiftleft by index into lut. Useful when sllv is not supported
alignas(64) const uint8_t shuffle_encoding_bitfield_1x8_off2[16] = {
    0x03, 0x0c, 0x30, 0xc0,
    0x03, 0x0c, 0x30, 0xc0,
    0x03, 0x0c, 0x30, 0xc0,
    0x03, 0x0c, 0x30, 0xc0
};

alignas(64) const uint8_t shuffle_encoding_bitfield_1x8_off1[16] = {
    0x01, 0x02, 0x04, 0x08,
    0x10, 0x20, 0x40, 0x80,
    0x01, 0x02, 0x04, 0x08,
    0x10, 0x20, 0x40, 0x80
};

alignas(64) const uint8_t shuffle_encoding_bitfield_shuffle_2bx32[32] = {
    0, 4, 8, 12,
    1, 5, 9, 13,
    2, 6, 10, 14,
    3, 7, 11, 15,
    0, 4, 8, 12,
    1, 5, 9, 13,
    2, 6, 10, 14,
    3, 7, 11, 15
};
   
alignas(64) const uint32_t shuffle_encoding_bitfield_sllv_2bx32[8] = {
    0, 2, 4, 6, 0, 2, 4, 6
};

alignas(64) const uint8_t conversion_2x8_1x8_shuffle[32] = {
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e
};

alignas(64) const uint8_t conversion_4x8_1x8_shuffle[32] = {
    0x00, 0x04, 0x08, 0x0c, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x04, 0x08, 0x0c,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

alignas(64) const uint8_t conversion_4x8_1x8_shuffle_hi[32] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x04, 0x08, 0x0c, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x04, 0x08, 0x0c
};

alignas(64) const uint8_t conversion_4fx8_cfp16x8_shuffle[32] = {
    0x00, 0x01, 0x04, 0x05, 0x08, 0x09, 0x0c, 0x0d,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x01, 0x04, 0x05, 0x08, 0x09, 0x0c, 0x0d,
};

alignas(64) const uint8_t conversion_8x4_2x4_shuffle[32] = {
    0x00, 0x01, 0x08, 0x09, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x01, 0x08, 0x09,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

alignas(64) const uint8_t conversion_8x4_1x4_shuffle[32] = {
    0x00, 0x08, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0x00, 0x08, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

alignas(64) const uint8_t conversion_4x4_2x4_shuffle[16] = {
    0x00, 0x01, 0x04, 0x05, 0x08, 0x09, 0x0c, 0x0d,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

alignas(64) const uint8_t sse42_4x4_evenodd_intlv_epi32[16] = {
    0x00, 0x01, 0x02, 0x03,
    0x08, 0x09, 0x0a, 0x0b,
    0x04, 0x05, 0x06, 0x07,
    0x0c, 0x0d, 0x0e, 0x0f
};

alignas(64) const uint32_t avx2_4x8_evenodd_intlv_epi32_vl4[8] = {
    0x00, 0x04, 0x01, 0x05, 0x02, 0x06, 0x03, 0x07
};

alignas(64) const uint32_t avx2_4x8_evenodd_intlv_inv_epi32_vl4[8] = {
    0x00, 0x02, 0x04, 0x06, 0x01, 0x03, 0x05, 0x07
};

alignas(64) const uint32_t avx512_4x16_evenodd_intlv_epi32_vl8[16] = {
    0x00, 0x08, 0x01, 0x09,
    0x02, 0x0a, 0x03, 0x0b,
    0x04, 0x0c, 0x05, 0x0d,
    0x06, 0x0e, 0x07, 0x0f
};

alignas(64) const uint32_t avx512_4x16_evenodd_intlv_inv_epi32_vl8[16] = {
    0x00, 0x02, 0x04, 0x06,
    0x08, 0x0a, 0x0c, 0x0e,
    0x01, 0x03, 0x05, 0x07,
    0x09, 0x0b, 0x0d, 0x0f
};

alignas(64) const uint32_t avx512_4x16_evenodd_intlv_epi32_vl16[16] = {
    0x00, 0x08, 0x01, 0x09,
    0x02, 0x0a, 0x03, 0x0b,
    0x04, 0x0c, 0x05, 0x0d,
    0x06, 0x0e, 0x07, 0x0f
};

alignas(64) const uint32_t avx512_4x16_evenodd_intlv_inv_epi32_vl16[16] = {
    0x00, 0x02, 0x04, 0x06,
    0x08, 0x0a, 0x0c, 0x0e,
    0x01, 0x03, 0x05, 0x07,
    0x09, 0x0b, 0x0d, 0x0f
};

alignas(64) const uint8_t avx2_1x32_array_encoding_permute_lut_vl4[32] = {
    0x00, // position of index 0
    0x02, // position of index 1
    0x04, // position of index 2
    0x06, // position of index 3
    0x01, // position of index 4
    0x03, // position of index 5
    0x05, // position of index 6
    0x07, // position of index 7
    0x08, // position of index 0
    0x0a, // position of index 1
    0x0c, // position of index 2
    0x0e, // position of index 3
    0x09, // position of index 4
    0x0b, // position of index 5
    0x0d, // position of index 6
    0x0f, // position of index 7
    // Same 16 values repeated for upper half of vector
    0x00, 0x02, 0x04, 0x06, 0x01, 0x03, 0x05, 0x07, 
    0x08, 0x0a, 0x0c, 0x0e, 0x09, 0x0b, 0x0d, 0x0f, 
};

alignas(64) const uint8_t avx512_1x32_array_encoding_permute_lut_vl8[64] = {
    0x00, // position of index 0
    0x02, // position of index 1
    0x04, // position of index 2
    0x06, // position of index 3
    0x08, // position of index 4
    0x0a, // position of index 5
    0x0c, // position of index 6
    0x0e, // position of index 7
    0x01, // position of index 8
    0x03, // position of index 9
    0x05, // position of index A
    0x07, // position of index B
    0x09, // position of index C
    0x0b, // position of index D
    0x0d, // position of index E
    0x0f, // position of index F
    // Same 16 values repeated for other 128-bit vectors
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 
    0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f, 
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 
    0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f, 
    0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 
    0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f
};

alignas(64) const uint64_t avx2_1x4_convert_to_8x4_lut[64] = {
    0x00000000000000000, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, // 0 0 0 0
    0xffffffffffffffff, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000, // 0 0 0 1
    0x0000000000000000, 0xffffffffffffffff, 0x0000000000000000, 0x0000000000000000, // 0 0 1 0
    0xffffffffffffffff, 0xffffffffffffffff, 0x0000000000000000, 0x0000000000000000, // 0 0 1 1
    0x0000000000000000, 0x0000000000000000, 0xffffffffffffffff, 0x0000000000000000, // 0 1 0 0
    0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff, 0x0000000000000000, // 0 1 0 1
    0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000000000000000, // 0 1 1 0
    0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000000000000000, // 0 1 1 1
    0x0000000000000000, 0x0000000000000000, 0x0000000000000000, 0xffffffffffffffff, // 1 0 0 0
    0xffffffffffffffff, 0x0000000000000000, 0x0000000000000000, 0xffffffffffffffff, // 0 0 0 1
    0x0000000000000000, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff, // 1 0 1 0
    0xffffffffffffffff, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff, // 1 0 1 1
    0x0000000000000000, 0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff, // 1 1 0 0
    0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff, // 1 1 0 1
    0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, // 1 1 1 0
    0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff  // 1 1 1 1
};

// Supports vector length up to 16
alignas(64) const uint32_t avx2_4x16_termination_lut_epi32[32] = {
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000
};

// Supports vector length up to 16 epi32 on either side
// Contains single 1 word
alignas(64) const uint32_t avx512_singleton_basis_epi32[64] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000001,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000
};

// Supports vector length up to 32 epi32 on either side
// Contains single word with 1 in top position followed by full ones
alignas(64) const uint32_t avx512_himask_basis_epi32[64] = {
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x80000000,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
};

alignas(64) const uint32_t mm_cstoreu_select[64] = {
    0, 0, 0, 0, // 0000
    0, 0, 0, 0, // 0001
    1, 0, 0, 0, // 0010
    0, 1, 0, 0, // 0011
    2, 0, 0, 0, // 0100
    0, 2, 0, 0, // 0101
    1, 2, 0, 0, // 0110
    0, 1, 2, 0, // 0111
    3, 0, 0, 0, // 1000
    0, 3, 0, 0, // 1001
    1, 3, 0, 0, // 1010
    0, 1, 3, 0, // 1011
    2, 3, 0, 0, // 1100
    0, 2, 3, 0, // 1101
    1, 2, 3, 0, // 1110
    0, 1, 2, 3  // 1111
};

const char * frontier_type_names[
    static_cast<std::underlying_type_t<frontier_type>>(
	frontier_type::ft_N )+1] = {
    "true",
    "unbacked",
    "bool",
    "bit",
    "logical1",
    "logical2",
    "logical4",
    "logical8",
    "sparse",
    "bit2",
    "msb4",
    "illegal-frontier-type"
};

const char * frontier_mode_names[fm_N+1] = {
    "all-true",
    "reduction",
    "calculate",
    "illegal-frontier-mode"
};

const char * graph_traversal_kind_names[
    static_cast<std::underlying_type_t<graph_traversal_kind>>(
	graph_traversal_kind::gt_N )+1] = {
    "sparse",
    "pull",
    "push",
    "irregular",
    "illegal-graph-traversal-kind"
};

frontier * zero_frontier = nullptr;
